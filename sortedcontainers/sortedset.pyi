from __future__ import annotations

import typing
from typing import (
    Any,
    AbstractSet,
    Callable,
    Generic,
    Hashable,
    Iterable,
    Iterator,
    List,
    MutableSet,
    Optional,
    Sequence,
    Tuple,
    Type,
    Set,
    TypeVar,
    Union,
)

# --- Global

T = TypeVar("T", bound=Hashable)
S = TypeVar("S", bound=Hashable)
Key = Callable[[T], Any]

class SortedSet(MutableSet[T], Sequence[T], Generic[T]):
    def __init__(self, iterable: Optional[Iterable[T]] = ..., key: Optional[Key] = ...) -> None: ...
    @classmethod
    def _fromset(cls, values: Set[T], key: Optional[Key] = ...) -> SortedSet[T]: ...
    @property
    def key(self) -> Optional[Key]: ...
    def __contains__(self, value: Any) -> bool: ...
    @typing.overload
    def __getitem__(self, index: int) -> T: ...
    @typing.overload
    def __getitem__(self, index: slice) -> List[T]: ...
    def __delitem__(self, index: Union[int, slice]) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __lt__(self, other: Iterable[T]) -> bool: ...
    def __gt__(self, other: Iterable[T]) -> bool: ...
    def __le__(self, other: Iterable[T]) -> bool: ...
    def __ge__(self, other: Iterable[T]) -> bool: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[T]: ...
    def __reversed__(self) -> Iterator[T]: ...
    def add(self, value: T) -> None: ...
    _add = add
    def clear(self) -> None: ...
    def copy(self) -> SortedSet[T]: ...
    __copy__ = copy
    def count(self, value: T) -> int: ...
    def discard(self, value: T) -> None: ...
    _discard = discard
    def pop(self, index: int = ...) -> T: ...
    def remove(self, value: T) -> None: ...
    def difference(self, *iterables: Iterable[S]) -> SortedSet[Union[T, S]]: ...
    __sub__ = difference
    def difference_update(self, *iterables: Iterable[S]) -> SortedSet[Union[T, S]]: ...
    __isub__ = difference_update
    def intersection(self, *iterables: Iterable[S]) -> SortedSet[Union[T, S]]: ...
    __and__ = intersection
    __rand__ = __and__
    def intersection_update(self, *iterables: Iterable[S]) -> SortedSet[Union[T, S]]: ...
    __iand__ = intersection_update
    def symmetric_difference(self, other: Iterable[S]) -> SortedSet[Union[T, S]]: ...
    __xor__ = symmetric_difference
    __rxor__ = __xor__
    def symmetric_difference_update(self, other: Iterable[S]) -> SortedSet[Union[T, S]]: ...
    __ixor__ = symmetric_difference_update
    def union(self, *iterables: Iterable[S]) -> SortedSet[Union[T, S]]: ...
    __or__ = union
    __ror__ = __or__
    def update(self, *iterables: Iterable[S]) -> SortedSet[Union[T, S]]: ...
    __ior__ = update
    _update = update
    def __reduce__(self) -> Tuple[Type[SortedSet[T]], Set[T], Callable[[T], Any]]: ...
    def __repr__(self) -> str: ...
    def _check(self) -> None: ...
