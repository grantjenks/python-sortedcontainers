from __future__ import annotations

import typing
from typing import Any, Callable, Iterable, Iterator, List, Optional, Tuple, Type, TypeVar, Union

T = TypeVar("T")
Key = Callable[[T], Any]
Repr = Callable[[], str]

def recursive_repr(fillvalue: str = ...) -> Callable[[Repr], Repr]: ...


class SortedList(typing.Generic[T], typing.MutableSequence[T]):

    DEFAULT_LOAD_FACTOR: int = ...
    def __init__(
        self, iterable: Optional[Iterable[T]] = ..., key: Optional[Key] = ...
    ): ...

    # NB: currently mypy does not honour return type, see mypy #3307
    @typing.overload
    def __new__(cls, iterable: None, key: None) -> SortedList[T]: ...
    @typing.overload
    def __new__(cls, iterable: None, key: Key) -> SortedKeyList[T]: ...
    @typing.overload
    def __new__(cls, iterable: Iterable[T], key: None) -> SortedList[T]: ...
    @typing.overload
    def __new__(cls, iterable: Iterable[T], key: Key) -> SortedKeyList[T]: ...

    @property
    def key(self) -> Optional[Callable[[T], Any]]: ...
    def _reset(self, load: int) -> None: ...
    def clear(self) -> None: ...
    _clear = clear
    def add(self, value: T) -> None: ...
    def _expand(self, pos: int) -> None: ...
    def update(self, iterable: Iterable[T]) -> None: ...
    _update = update
    def discard(self, value: T) -> None: ...
    def remove(self, value: T) -> None: ...
    def _delete(self, pos: int, idx: int) -> None: ...
    def _loc(self, pos: int, idx: int) -> int: ...
    def _pos(self, idx: int) -> int: ...
    def _build_index(self) -> None: ...
    def __contains__(self, value: Any) -> bool: ...
    def __delitem__(self, index: Union[int, slice]) -> None: ...
    @typing.overload
    def __getitem__(self, index: int) -> T: ...
    @typing.overload
    def __getitem__(self, index: slice) -> List[T]: ...
    _getitem = __getitem__
    @typing.overload
    def __setitem__(self, index: int, value: T) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: Iterable[T]) -> None: ...
    def __iter__(self) -> Iterator[T]: ...
    def __reversed__(self) -> Iterator[T]: ...
    def __len__(self) -> int: ...
    def reverse(self) -> None: ...
    def islice(
        self, start: Optional[int] = ..., stop: Optional[int] = ..., reverse=bool
    ) -> Iterator[T]: ...
    def _islice(
        self, min_pos: int, min_idx: int, max_pos: int, max_idx: int, reverse: bool
    ) -> Iterator[T]: ...
    def irange(
        self,
        minimum: Optional[int] = ...,
        maximum: Optional[int] = ...,
        inclusive: Tuple[bool, bool] = ...,
        reverse: bool = ...,
    ) -> Iterator[T]: ...
    def bisect_left(self, value: T) -> int: ...
    def bisect_right(self, value: T) -> int: ...
    bisect = bisect_right
    _bisect_right = bisect_right
    def count(self, value: T) -> int: ...
    def copy(self) -> SortedList[T]: ...
    __copy__ = copy
    def append(self, value: T) -> None: ...
    def extend(self, values: Iterable[T]) -> None: ...
    def insert(self, index: int, value: T) -> None: ...
    def pop(self, index: int = -1) -> T: ...
    def index(self, value: T, start: Optional[int] = None, stop: Optional[int] = None) -> int: ...
    def __add__(self, other: Iterable[T]) -> SortedList[T]: ...
    __radd__ = __add__
    def __iadd__(self, other: Iterable[T]) -> SortedList[T]: ...
    def __mul__(self, num: int) -> SortedList[T]: ...
    __rmul__ = __mul__
    def __imul__(self, num: int) -> SortedList[T]: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __lt__(self, other: typing.Sequence[T]) -> bool: ...
    def __gt__(self, other: typing.Sequence[T]) -> bool: ...
    def __le__(self, other: typing.Sequence[T]) -> bool: ...
    def __ge__(self, other: typing.Sequence[T]) -> bool: ...
    def __repr__(self) -> str: ...
    def _check(self) -> None: ...

class SortedKeyList(typing.Generic[T], SortedList[T]):
    def __init__(
        self, iterable: Optional[Iterable[T]] = ..., key: Callable[[T], Any] = ...
    ) -> None: ...
    def __new__(
        cls, iterable: Optional[Iterable[T]] = ..., key: Callable[[T], Any] = ...
    ) -> SortedKeyList[T]: ...
    @property
    def key(self) -> Callable[[T], Any]: ...
    def clear(self) -> None: ...
    _clear = clear
    def add(self, value: T) -> None: ...
    def _expand(self, pos: int) -> None: ...
    def update(self, iterable: Iterable[T]) -> None: ...
    _update = update

    # NB: Should be T to be safely passed to self.func, but base class imposes Any
    def __contains__(
        self, value: Any
    ) -> bool: ...
    def discard(self, value: T) -> None: ...
    def remove(self, value: T) -> None: ...
    def _delete(self, pos: int, idx: int) -> None: ...
    def irange(
        self,
        minimum: Optional[int] = ...,
        maximum: Optional[int] = ...,
        inclusive: Tuple[bool, bool] = ...,
        reverse: bool = ...,
    ): ...
    def irange_key(
        self,
        min_key: Optional[Any] = ...,
        max_key: Optional[Any] = ...,
        inclusive: Tuple[bool, bool] = ...,
        reserve: bool = ...,
    ): ...
    def bisect_left(self, value: T) -> int: ...
    def bisect_right(self, value: T) -> int: ...
    bisect = bisect_right
    def bisect_key_left(self, key: Any) -> int: ...
    _bisect_key_left = bisect_key_left
    def bisect_key_right(self, key: Any) -> int: ...
    bisect_key = bisect_key_right
    _bisect_key_right = bisect_key_right
    def count(self, value: T) -> int: ...
    def copy(self) -> SortedKeyList[T]: ...
    __copy__ = copy
    def index(self, value: T, start: Optional[int] = ..., stop: Optional[int] = ...) -> int: ...
    def __add__(self, other: Iterable[T]) -> SortedKeyList[T]: ...
    __radd__ = __add__
    def __mul__(self, num: int) -> SortedKeyList[T]: ...
    def __repr__(self) -> str: ...
    def _check(self) -> None: ...

SortedListWithKey = SortedKeyList
