from __future__ import annotations

import typing
from typing import (
    Any,
    Callable,
    Dict,
    Generic,
    Iterator,
    Iterable,
    ItemsView,
    KeysView,
    List,
    Mapping,
    Optional,
    Sequence,
    Type,
    Tuple,
    Union,
    ValuesView,
)

T = typing.TypeVar("T")
S = typing.TypeVar("S")
KT = typing.TypeVar("KT", bound=typing.Hashable)  # Key type.
VT = typing.TypeVar("VT")  # Value type.
Key = Callable[[KT], Any]

class SortedDict(typing.Dict[KT, VT], typing.Generic[KT, VT]):
    @typing.overload
    def __init__(self, **kwargs: VT) -> None: ...
    @typing.overload
    def __init__(self, map: Mapping[KT, VT], **kwargs: VT) -> None: ...
    @typing.overload
    def __init__(self, iterable: Iterable[Tuple[KT, VT]], **kwargs: VT) -> None: ...
    @typing.overload
    def __init__(self, key: Key, **kwargs: VT) -> None: ...
    @typing.overload
    def __init__(self, key: Key, map: Mapping[KT, VT], **kwargs: VT) -> None: ...
    @typing.overload
    def __init__(self, key: Key, iterable: Iterable[Tuple[KT, VT]], **kwargs: VT) -> None: ...
    @property
    def key(self) -> Optional[Key]: ...
    @property
    def iloc(self) -> SortedKeysView[KT]: ...
    def clear(self) -> None: ...
    def __delitem__(self, key: KT) -> None: ...
    def __iter__(self) -> Iterator[KT]: ...
    def __reversed__(self) -> Iterator[KT]: ...
    def __setitem__(self, key: KT, value: VT) -> None: ...
    _setitem = __setitem__
    def copy(self) -> SortedDict[KT, VT]: ...
    __copy__ = copy
    @classmethod
    @typing.overload
    def fromkeys(cls, seq: Iterable[T]) -> SortedDict[T, None]: ...
    @classmethod
    @typing.overload
    def fromkeys(cls, seq: Iterable[T], value: S) -> SortedDict[T, S]: ...
    def keys(self) -> SortedKeysView[KT]: ...
    def items(self) -> SortedItemsView[KT, VT]: ...
    def values(self) -> SortedValuesView[VT]: ...
    @typing.overload
    def pop(self, key: KT) -> VT: ...
    @typing.overload
    def pop(self, key: KT, default: T = ...) -> Union[VT, T]: ...
    def popitem(self, index: int = ...) -> Tuple[KT, VT]: ...
    def peekitem(self, index: int = ...) -> Tuple[KT, VT]: ...
    def setdefault(self, key: KT, default: Optional[VT] = None) -> VT: ...
    def update(self, *args: Union[Mapping[KT, VT], Iterable[Tuple[KT, VT]]], **kwargs: VT): ...
    def __reduce__(
        self
    ) -> Tuple[Type[SortedDict[KT, VT]], Tuple[Callable[[KT], Any], List[Tuple[KT, VT]]]]: ...
    def __repr__(self) -> str: ...
    def _check(self) -> None: ...

class SortedKeysView(Generic[KT], KeysView[KT], Sequence[KT]):
    @typing.overload
    def __getitem__(self, index: int) -> KT: ...
    @typing.overload
    def __getitem__(self, index: slice) -> List[KT]: ...
    def __delitem__(self, index: Union[int, slice]) -> None: ...

# NB: currently errors, see mypy #5973
class SortedItemsView(Generic[KT, VT], ItemsView[KT, VT], Sequence[Tuple[KT, VT]]):
    def __iter__(self) -> Iterator[Tuple[KT, VT]]: ...
    @typing.overload
    def __getitem__(self, index: int) -> Tuple[KT, VT]: ...
    @typing.overload
    def __getitem__(self, index: slice) -> List[Tuple[KT, VT]]: ...
    def __delitem__(self, index: Union[int, slice]) -> None: ...

class SortedValuesView(Generic[VT], ValuesView[VT], Sequence[VT]):
    @typing.overload
    def __getitem__(self, index: int) -> VT: ...
    @typing.overload
    def __getitem__(self, index: slice) -> List[VT]: ...
    def __delitem__(self, index: Union[int, slice]) -> None: ...
